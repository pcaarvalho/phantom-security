"""
Advanced Vulnerability Scanner with Nuclei integration
"""
import asyncio
import subprocess
import json
import os
import tempfile
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import aiohttp
import re

from app.core.scanner.base_scanner import BaseScanner
from app.config import settings

logger = logging.getLogger(__name__)

class VulnerabilityScanner(BaseScanner):
    """
    Comprehensive vulnerability scanner using Nuclei and custom checks
    """
    
    def __init__(self, target: str):
        super().__init__(target)
        self.vulnerabilities = []
        self.nuclei_path = self._find_nuclei()
        self.template_paths = self._get_template_paths()
        
    def _find_nuclei(self) -> str:
        """Find nuclei binary path"""
        # Check common locations
        paths = [
            "/usr/local/bin/nuclei",
            "/usr/bin/nuclei",
            "/opt/nuclei/nuclei",
            "nuclei"  # Try PATH
        ]
        
        for path in paths:
            try:
                result = subprocess.run([path, "-version"], capture_output=True, timeout=5)
                if result.returncode == 0:
                    logger.info(f"[VULN] Found Nuclei at: {path}")
                    return path
            except:
                continue
                
        logger.warning("[VULN] Nuclei not found, will use fallback scanning")
        return None
        
    def _get_template_paths(self) -> List[str]:
        """Get Nuclei template paths"""
        templates = []
        
        # Common template locations
        template_dirs = [
            "/opt/nuclei-templates",
            "/usr/share/nuclei-templates",
            "~/nuclei-templates",
            "./nuclei-templates"
        ]
        
        for template_dir in template_dirs:
            expanded = os.path.expanduser(template_dir)
            if os.path.exists(expanded):
                templates.append(expanded)
                
        # If no templates found, we'll download them
        if not templates and self.nuclei_path:
            default_path = os.path.expanduser("~/.local/nuclei-templates")
            if not os.path.exists(default_path):
                self._download_templates(default_path)
            if os.path.exists(default_path):
                templates.append(default_path)
                
        return templates
        
    def _download_templates(self, path: str) -> bool:
        """Download Nuclei templates"""
        try:
            logger.info("[VULN] Downloading Nuclei templates...")
            subprocess.run([
                "git", "clone", 
                "https://github.com/projectdiscovery/nuclei-templates.git",
                path
            ], check=True, timeout=60)
            return True
        except Exception as e:
            logger.error(f"[VULN] Failed to download templates: {str(e)}")
            return False
    
    async def scan(self) -> Dict[str, Any]:
        """Run basic vulnerability scan"""
        if not self.validate_target():
            raise ValueError(f"Invalid target: {self.target}")
        
        self.start_time = asyncio.get_event_loop().time()
        
        # Run vulnerability scans
        if self.nuclei_path:
            await self._run_nuclei_scan()
        else:
            await self._run_fallback_scan()
        
        self.end_time = asyncio.get_event_loop().time()
        
        self.results = {
            "target": self.target,
            "scan_type": "vulnerability_scan",
            "vulnerabilities": self.vulnerabilities,
            "total_found": len(self.vulnerabilities),
            "severity_breakdown": self._calculate_severity_breakdown(),
            "scan_duration": self.end_time - self.start_time,
            "scanner_used": "nuclei" if self.nuclei_path else "fallback"
        }
        
        return self.results
        
    async def scan_comprehensive(self, services: List[Dict] = None, 
                               web_findings: Dict = None) -> Dict[str, Any]:
        """
        Run comprehensive vulnerability scan with context from other scanners
        """
        if not self.validate_target():
            raise ValueError(f"Invalid target: {self.target}")
            
        self.start_time = asyncio.get_event_loop().time()
        
        logger.info(f"[VULN] Starting comprehensive scan for {self.target}")
        
        # Run different types of scans based on discovered services
        tasks = []
        
        # Always run general vulnerability scan
        if self.nuclei_path:
            tasks.append(self._run_nuclei_scan())
        else:
            tasks.append(self._run_fallback_scan())
            
        # If web services detected, run web-specific scans
        if web_findings or self._has_web_service(services):
            tasks.append(self._run_web_vulnerability_scan())
            
        # If database services detected, run database-specific scans
        if self._has_database_service(services):
            tasks.append(self._run_database_vulnerability_scan(services))
            
        # Run custom vulnerability checks
        tasks.append(self._run_custom_checks())
        
        # Execute all scans concurrently
        await asyncio.gather(*tasks, return_exceptions=True)
        
        self.end_time = asyncio.get_event_loop().time()
        
        # Deduplicate and sort vulnerabilities
        self._deduplicate_vulnerabilities()
        self._sort_vulnerabilities_by_severity()
        
        self.results = {
            "target": self.target,
            "scan_type": "comprehensive_vulnerability_scan",
            "vulnerabilities": self.vulnerabilities,
            "total_found": len(self.vulnerabilities),
            "severity_breakdown": self._calculate_severity_breakdown(),
            "scan_duration": self.end_time - self.start_time,
            "context": {
                "services_analyzed": len(services) if services else 0,
                "web_findings_used": bool(web_findings)
            }
        }
        
        logger.info(f"[VULN] Scan completed. Found {len(self.vulnerabilities)} vulnerabilities")
        
        return self.results
        
    async def _run_nuclei_scan(self) -> None:
        """Run Nuclei vulnerability scanner"""
        logger.info("[VULN] Running Nuclei scan...")
        
        # Prepare target URL
        target_url = self.target
        if not target_url.startswith(('http://', 'https://')):
            target_url = f"https://{target_url}"
            
        # Build Nuclei command
        cmd = [self.nuclei_path, "-u", target_url, "-json", "-silent"]
        
        # Add severity filters (scan critical and high by default for speed)
        cmd.extend(["-severity", "critical,high,medium"])
        
        # Add template paths
        for template_path in self.template_paths:
            cmd.extend(["-t", template_path])
            
        # Add rate limiting to be respectful
        cmd.extend(["-rate-limit", "10", "-bulk-size", "25"])
        
        # Add timeout
        cmd.extend(["-timeout", "10"])
        
        try:
            # Create temporary file for output
            with tempfile.NamedTemporaryFile(mode='w+', suffix='.json', delete=False) as tmp:
                tmp_path = tmp.name
                
            # Run Nuclei
            logger.info(f"[VULN] Executing: {' '.join(cmd[:3])}...")
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=300  # 5 minute timeout
            )
            
            # Parse JSON output line by line
            if stdout:
                for line in stdout.decode().split('\n'):
                    if line.strip():
                        try:
                            vuln = json.loads(line)
                            self._parse_nuclei_finding(vuln)
                        except json.JSONDecodeError:
                            continue
                            
            # Clean up temp file
            try:
                os.unlink(tmp_path)
            except:
                pass
                
            logger.info(f"[VULN] Nuclei scan completed. Found {len(self.vulnerabilities)} vulnerabilities")
            
        except asyncio.TimeoutError:
            logger.error("[VULN] Nuclei scan timed out")
        except Exception as e:
            logger.error(f"[VULN] Nuclei scan failed: {str(e)}")
            
    def _parse_nuclei_finding(self, finding: Dict) -> None:
        """Parse a Nuclei finding into our vulnerability format"""
        try:
            info = finding.get("info", {})
            
            vulnerability = {
                "template_id": finding.get("template-id", "unknown"),
                "template_name": info.get("name", "Unknown Vulnerability"),
                "severity": info.get("severity", "unknown").upper(),
                "description": info.get("description", "No description available"),
                "matched_at": finding.get("matched-at", ""),
                "matcher_name": finding.get("matcher-name", ""),
                "type": finding.get("type", ""),
                "host": finding.get("host", self.target),
                "path": finding.get("path", ""),
                "tags": info.get("tags", []),
                "reference": info.get("reference", []),
                "cvss_metrics": info.get("classification", {}).get("cvss-metrics", ""),
                "cvss_score": info.get("classification", {}).get("cvss-score", 0),
                "cve_id": info.get("classification", {}).get("cve-id", []),
                "cwe_id": info.get("classification", {}).get("cwe-id", []),
                "extracted_results": finding.get("extracted-results", []),
                "curl_command": finding.get("curl-command", ""),
                "timestamp": datetime.now().isoformat()
            }
            
            # Add remediation if available
            if "remediation" in info:
                vulnerability["remediation"] = info["remediation"]
                
            self.vulnerabilities.append(vulnerability)
            
        except Exception as e:
            logger.error(f"[VULN] Error parsing Nuclei finding: {str(e)}")
            
    async def _run_fallback_scan(self) -> None:
        """Run fallback vulnerability checks when Nuclei is not available"""
        logger.info("[VULN] Running fallback vulnerability scan...")
        
        tasks = [
            self._check_common_vulnerabilities(),
            self._check_security_misconfigurations(),
            self._check_information_disclosure(),
            self._check_injection_vulnerabilities()
        ]
        
        await asyncio.gather(*tasks, return_exceptions=True)
        
    async def _run_web_vulnerability_scan(self) -> None:
        """Run web-specific vulnerability scans"""
        logger.info("[VULN] Running web vulnerability scan...")
        
        tasks = [
            self._check_xss_vulnerabilities(),
            self._check_csrf_vulnerabilities(),
            self._check_path_traversal(),
            self._check_file_upload_vulnerabilities(),
            self._check_api_vulnerabilities()
        ]
        
        await asyncio.gather(*tasks, return_exceptions=True)
        
    async def _run_database_vulnerability_scan(self, services: List[Dict]) -> None:
        """Run database-specific vulnerability scans"""
        logger.info("[VULN] Running database vulnerability scan...")
        
        # Identify database services
        db_services = [s for s in services if self._is_database_service(s)]
        
        for service in db_services:
            if 'mysql' in service.get('service', '').lower():
                await self._check_mysql_vulnerabilities(service)
            elif 'postgres' in service.get('service', '').lower():
                await self._check_postgresql_vulnerabilities(service)
            elif 'mongodb' in service.get('service', '').lower():
                await self._check_mongodb_vulnerabilities(service)
            elif 'redis' in service.get('service', '').lower():
                await self._check_redis_vulnerabilities(service)
                
    async def _run_custom_checks(self) -> None:
        """Run custom vulnerability checks"""
        tasks = [
            self._check_subdomain_takeover(),
            self._check_git_exposure(),
            self._check_backup_files(),
            self._check_admin_interfaces(),
            self._check_debug_endpoints()
        ]
        
        await asyncio.gather(*tasks, return_exceptions=True)
        
    async def _check_common_vulnerabilities(self) -> None:
        """Check for common vulnerabilities"""
        # Check for common CVEs based on detected services
        common_vulns = [
            {
                "name": "Log4Shell",
                "cve": "CVE-2021-44228",
                "check": self._check_log4shell
            },
            {
                "name": "Spring4Shell", 
                "cve": "CVE-2022-22965",
                "check": self._check_spring4shell
            },
            {
                "name": "ProxyLogon",
                "cve": "CVE-2021-26855",
                "check": self._check_proxylogon
            }
        ]
        
        for vuln in common_vulns:
            try:
                if await vuln["check"]():
                    self.vulnerabilities.append({
                        "template_name": vuln["name"],
                        "severity": "CRITICAL",
                        "cve_id": [vuln["cve"]],
                        "description": f"Potential {vuln['name']} vulnerability detected",
                        "matched_at": self.target,
                        "timestamp": datetime.now().isoformat()
                    })
            except:
                continue
                
    async def _check_log4shell(self) -> bool:
        """Check for Log4Shell vulnerability"""
        # Simplified check - in production would be more comprehensive
        try:
            headers = {
                "X-Api-Version": "${jndi:ldap://log4shell.test/a}"
            }
            
            async with aiohttp.ClientSession() as session:
                url = f"https://{self.target}" if not self.target.startswith('http') else self.target
                async with session.get(url, headers=headers, timeout=10, ssl=False) as response:
                    # Check if the payload was processed (simplified check)
                    return False  # Would need actual LDAP listener to confirm
        except:
            return False
            
    async def _check_spring4shell(self) -> bool:
        """Check for Spring4Shell vulnerability"""
        # Simplified check
        return False
        
    async def _check_proxylogon(self) -> bool:
        """Check for ProxyLogon vulnerability"""
        # Simplified check
        return False
        
    async def _check_security_misconfigurations(self) -> None:
        """Check for security misconfigurations"""
        # Check for common misconfigurations
        checks = [
            ("/.git/", "Git Repository Exposed"),
            ("/.env", "Environment File Exposed"),
            ("/wp-config.php.bak", "WordPress Backup File"),
            ("/web.config", "IIS Configuration File"),
            ("/.htaccess", "Apache Configuration File"),
            ("/server-status", "Apache Server Status"),
            ("/phpinfo.php", "PHP Info Page"),
            ("/.DS_Store", "Directory Listing"),
            ("/backup.zip", "Backup File Exposed"),
            ("/database.sql", "Database Dump Exposed")
        ]
        
        async with aiohttp.ClientSession() as session:
            for path, vuln_name in checks:
                try:
                    url = f"https://{self.target}{path}" if not self.target.startswith('http') else f"{self.target}{path}"
                    async with session.get(url, timeout=5, ssl=False) as response:
                        if response.status == 200:
                            self.vulnerabilities.append({
                                "template_name": vuln_name,
                                "severity": "HIGH",
                                "description": f"{vuln_name} at {path}",
                                "matched_at": url,
                                "path": path,
                                "timestamp": datetime.now().isoformat()
                            })
                except:
                    continue
                    
    async def _check_information_disclosure(self) -> None:
        """Check for information disclosure vulnerabilities"""
        # Check for sensitive information in robots.txt, sitemap.xml, etc.
        pass
        
    async def _check_injection_vulnerabilities(self) -> None:
        """Check for injection vulnerabilities"""
        # Basic SQL injection checks
        pass
        
    async def _check_xss_vulnerabilities(self) -> None:
        """Check for XSS vulnerabilities"""
        # Basic XSS checks
        pass
        
    async def _check_csrf_vulnerabilities(self) -> None:
        """Check for CSRF vulnerabilities"""
        pass
        
    async def _check_path_traversal(self) -> None:
        """Check for path traversal vulnerabilities"""
        pass
        
    async def _check_file_upload_vulnerabilities(self) -> None:
        """Check for file upload vulnerabilities"""
        pass
        
    async def _check_api_vulnerabilities(self) -> None:
        """Check for API-specific vulnerabilities"""
        pass
        
    async def _check_mysql_vulnerabilities(self, service: Dict) -> None:
        """Check for MySQL-specific vulnerabilities"""
        port = service.get('port', 3306)
        version = service.get('version', '')
        
        # Check for known MySQL vulnerabilities based on version
        if '5.5' in version:
            self.vulnerabilities.append({
                "template_name": "MySQL 5.5 Multiple Vulnerabilities",
                "severity": "HIGH",
                "description": "MySQL 5.5 has known security vulnerabilities",
                "matched_at": f"{self.target}:{port}",
                "remediation": "Upgrade to MySQL 5.7 or later",
                "timestamp": datetime.now().isoformat()
            })
            
    async def _check_postgresql_vulnerabilities(self, service: Dict) -> None:
        """Check for PostgreSQL-specific vulnerabilities"""
        pass
        
    async def _check_mongodb_vulnerabilities(self, service: Dict) -> None:
        """Check for MongoDB-specific vulnerabilities"""
        pass
        
    async def _check_redis_vulnerabilities(self, service: Dict) -> None:
        """Check for Redis-specific vulnerabilities"""
        port = service.get('port', 6379)
        
        # Check if Redis is exposed without authentication
        try:
            reader, writer = await asyncio.open_connection(self.target, port)
            writer.write(b"INFO\r\n")
            await writer.drain()
            
            data = await asyncio.wait_for(reader.read(1024), timeout=5)
            
            if b"redis_version" in data:
                self.vulnerabilities.append({
                    "template_name": "Redis Unauthenticated Access",
                    "severity": "CRITICAL",
                    "description": "Redis server accessible without authentication",
                    "matched_at": f"{self.target}:{port}",
                    "remediation": "Enable Redis authentication with requirepass",
                    "timestamp": datetime.now().isoformat()
                })
                
            writer.close()
            await writer.wait_closed()
        except:
            pass
            
    async def _check_subdomain_takeover(self) -> None:
        """Check for subdomain takeover vulnerabilities"""
        pass
        
    async def _check_git_exposure(self) -> None:
        """Check for exposed Git repositories"""
        pass
        
    async def _check_backup_files(self) -> None:
        """Check for exposed backup files"""
        pass
        
    async def _check_admin_interfaces(self) -> None:
        """Check for exposed admin interfaces"""
        admin_paths = [
            "/admin", "/administrator", "/wp-admin", "/phpmyadmin",
            "/adminer", "/manager", "/console", "/controlpanel"
        ]
        
        async with aiohttp.ClientSession() as session:
            for path in admin_paths:
                try:
                    url = f"https://{self.target}{path}" if not self.target.startswith('http') else f"{self.target}{path}"
                    async with session.get(url, timeout=5, ssl=False, allow_redirects=False) as response:
                        if response.status in [200, 301, 302, 401, 403]:
                            self.vulnerabilities.append({
                                "template_name": "Admin Interface Exposed",
                                "severity": "MEDIUM",
                                "description": f"Admin interface found at {path}",
                                "matched_at": url,
                                "path": path,
                                "timestamp": datetime.now().isoformat()
                            })
                except:
                    continue
                    
    async def _check_debug_endpoints(self) -> None:
        """Check for exposed debug endpoints"""
        pass
        
    def _has_web_service(self, services: List[Dict]) -> bool:
        """Check if web services are present"""
        if not services:
            return True  # Assume web if no services provided
            
        web_ports = [80, 443, 8080, 8443, 8000, 8888]
        web_services = ['http', 'https', 'ssl/http', 'ssl/https']
        
        for service in services:
            if service.get('port') in web_ports:
                return True
            if any(web in service.get('service', '').lower() for web in web_services):
                return True
                
        return False
        
    def _has_database_service(self, services: List[Dict]) -> bool:
        """Check if database services are present"""
        if not services:
            return False
            
        db_keywords = ['mysql', 'postgres', 'mongodb', 'redis', 'mssql', 'oracle', 'cassandra']
        
        for service in services:
            service_name = service.get('service', '').lower()
            if any(db in service_name for db in db_keywords):
                return True
                
        return False
        
    def _is_database_service(self, service: Dict) -> bool:
        """Check if a service is a database"""
        db_keywords = ['mysql', 'postgres', 'mongodb', 'redis', 'mssql', 'oracle', 'cassandra']
        service_name = service.get('service', '').lower()
        return any(db in service_name for db in db_keywords)
        
    def _deduplicate_vulnerabilities(self) -> None:
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique_vulns = []
        
        for vuln in self.vulnerabilities:
            # Create a unique key for the vulnerability
            key = (
                vuln.get('template_name', ''),
                vuln.get('matched_at', ''),
                vuln.get('path', '')
            )
            
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
                
        self.vulnerabilities = unique_vulns
        
    def _sort_vulnerabilities_by_severity(self) -> None:
        """Sort vulnerabilities by severity"""
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'INFO': 4, 'UNKNOWN': 5}
        
        self.vulnerabilities.sort(
            key=lambda x: severity_order.get(x.get('severity', 'UNKNOWN').upper(), 5)
        )
    
    def _calculate_severity_breakdown(self) -> Dict[str, int]:
        """Calculate vulnerability severity breakdown"""
        breakdown = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for vuln in self.vulnerabilities:
            severity = vuln.get("severity", "info").lower()
            if severity in breakdown:
                breakdown[severity] += 1
        
        return breakdown