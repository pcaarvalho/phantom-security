"""
Vulnerability prioritization engine using CVSS, business context, and threat intelligence
"""

import logging
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import re
import math

logger = logging.getLogger(__name__)


class Severity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class ExploitabilityLevel(Enum):
    """Levels of exploitability based on available exploits"""
    ACTIVE_EXPLOITATION = "active"      # Known to be exploited in the wild
    PUBLIC_EXPLOIT = "public"          # Public exploit code available
    PROOF_OF_CONCEPT = "poc"           # PoC exploit available
    FUNCTIONAL_EXPLOIT = "functional"   # Functional exploit exists
    THEORETICAL = "theoretical"        # Only theoretical exploitation
    UNKNOWN = "unknown"               # Exploitability unknown


@dataclass
class BusinessContext:
    """Business context for vulnerability prioritization"""
    asset_criticality: float = 0.5    # 0.0 (low) to 1.0 (critical)
    data_sensitivity: float = 0.5     # 0.0 (public) to 1.0 (top secret)
    external_exposure: bool = False   # Exposed to internet
    compliance_requirement: bool = False  # Subject to compliance
    business_impact_score: float = 0.5    # Overall business impact
    
    
@dataclass 
class ThreatIntelligence:
    """Threat intelligence data for vulnerability"""
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None
    exploitability: ExploitabilityLevel = ExploitabilityLevel.UNKNOWN
    threat_actor_activity: bool = False
    ransomware_campaigns: bool = False
    apt_usage: bool = False
    exploit_kits: bool = False
    mass_exploitation: bool = False
    patch_available: bool = False
    patch_age_days: Optional[int] = None


@dataclass
class VulnerabilityScore:
    """Comprehensive vulnerability scoring"""
    base_score: float = 0.0           # Base CVSS or severity score
    exploitability_score: float = 0.0 # Exploitability multiplier
    business_score: float = 0.0       # Business context score
    threat_score: float = 0.0         # Threat intelligence score
    temporal_score: float = 0.0       # Time-based factors
    final_score: float = 0.0          # Final composite score
    priority_level: Severity = Severity.INFO
    reasoning: List[str] = field(default_factory=list)


class VulnerabilityPrioritizer:
    """Intelligent vulnerability prioritization engine"""
    
    def __init__(self):
        self.cvss_patterns = {
            "AV:N": 1.0,    # Network vector = highest
            "AV:A": 0.8,    # Adjacent network
            "AV:L": 0.6,    # Local
            "AV:P": 0.4,    # Physical
            
            "AC:L": 1.0,    # Low complexity = easier
            "AC:H": 0.7,    # High complexity
            
            "PR:N": 1.0,    # No privileges required
            "PR:L": 0.8,    # Low privileges
            "PR:H": 0.6,    # High privileges
            
            "UI:N": 1.0,    # No user interaction
            "UI:R": 0.8,    # User interaction required
            
            "C:H": 1.0,     # High confidentiality impact
            "C:L": 0.6,     # Low confidentiality impact
            "C:N": 0.3,     # No confidentiality impact
            
            "I:H": 1.0,     # High integrity impact
            "I:L": 0.6,     # Low integrity impact
            "I:N": 0.3,     # No integrity impact
            
            "A:H": 1.0,     # High availability impact
            "A:L": 0.6,     # Low availability impact
            "A:N": 0.3,     # No availability impact
        }
        
        self.known_exploit_patterns = [
            # SQL Injection patterns
            r"sql.injection|sqli",
            r"union.select|blind.sql",
            
            # XSS patterns
            r"cross.site.scripting|xss",
            r"reflected.xss|stored.xss",
            
            # RCE patterns
            r"remote.code.execution|rce",
            r"command.injection|code.injection",
            
            # Authentication bypass
            r"authentication.bypass|auth.bypass",
            r"privilege.escalation",
            
            # Directory traversal
            r"path.traversal|directory.traversal",
            r"local.file.inclusion|lfi",
            
            # Deserialization
            r"deserialization|unsafe.deserialization",
            
            # XXE
            r"xml.external.entity|xxe",
        ]
    
    def prioritize_vulnerabilities(
        self,
        vulnerabilities: List[Dict[str, Any]],
        business_context: BusinessContext = None,
        threat_intel: Dict[str, ThreatIntelligence] = None
    ) -> List[Dict[str, Any]]:
        """Prioritize vulnerabilities based on multiple factors"""
        
        if not vulnerabilities:
            return []
        
        business_context = business_context or BusinessContext()
        threat_intel = threat_intel or {}
        
        scored_vulns = []
        
        for vuln in vulnerabilities:
            score = self.calculate_vulnerability_score(
                vuln, business_context, threat_intel.get(vuln.get("id"))
            )
            
            vuln_copy = vuln.copy()
            vuln_copy["priority_score"] = score.final_score
            vuln_copy["priority_level"] = score.priority_level.value
            vuln_copy["scoring_details"] = {
                "base_score": score.base_score,
                "exploitability_score": score.exploitability_score,
                "business_score": score.business_score,
                "threat_score": score.threat_score,
                "temporal_score": score.temporal_score,
                "reasoning": score.reasoning
            }
            
            scored_vulns.append(vuln_copy)
        
        # Sort by priority score (highest first)
        scored_vulns.sort(key=lambda v: v["priority_score"], reverse=True)
        
        logger.info(f"Prioritized {len(scored_vulns)} vulnerabilities")
        return scored_vulns
    
    def calculate_vulnerability_score(
        self,
        vulnerability: Dict[str, Any],
        business_context: BusinessContext,
        threat_intel: Optional[ThreatIntelligence] = None
    ) -> VulnerabilityScore:
        """Calculate comprehensive vulnerability score"""
        
        score = VulnerabilityScore()
        threat_intel = threat_intel or ThreatIntelligence()
        
        # 1. Base Score (40% weight)
        score.base_score = self._calculate_base_score(vulnerability)
        
        # 2. Exploitability Score (25% weight) 
        score.exploitability_score = self._calculate_exploitability_score(
            vulnerability, threat_intel
        )
        
        # 3. Business Score (20% weight)
        score.business_score = self._calculate_business_score(
            vulnerability, business_context
        )
        
        # 4. Threat Intelligence Score (10% weight)
        score.threat_score = self._calculate_threat_score(threat_intel)
        
        # 5. Temporal Score (5% weight)
        score.temporal_score = self._calculate_temporal_score(threat_intel)
        
        # Calculate final weighted score
        score.final_score = (
            score.base_score * 0.40 +
            score.exploitability_score * 0.25 +
            score.business_score * 0.20 +
            score.threat_score * 0.10 +
            score.temporal_score * 0.05
        )
        
        # Determine priority level
        score.priority_level = self._determine_priority_level(score.final_score)
        
        # Add reasoning
        score.reasoning = self._generate_reasoning(
            vulnerability, business_context, threat_intel, score
        )
        
        return score
    
    def _calculate_base_score(self, vulnerability: Dict[str, Any]) -> float:
        """Calculate base vulnerability score"""
        # Check for CVSS score first
        cvss_score = vulnerability.get("cvss_score")
        if cvss_score and isinstance(cvss_score, (int, float)):
            return min(cvss_score / 10.0, 1.0)  # Normalize to 0-1
        
        # Check CVSS vector
        cvss_vector = vulnerability.get("cvss_vector")
        if cvss_vector:
            return self._parse_cvss_vector(cvss_vector)
        
        # Fallback to severity mapping
        severity = vulnerability.get("severity", "").lower()
        severity_scores = {
            "critical": 0.95,
            "high": 0.8,
            "medium": 0.6,
            "low": 0.4,
            "info": 0.2
        }
        
        return severity_scores.get(severity, 0.5)
    
    def _parse_cvss_vector(self, cvss_vector: str) -> float:
        """Parse CVSS vector string and calculate score"""
        if not cvss_vector:
            return 0.5
        
        score = 0.0
        components = cvss_vector.split("/")
        
        for component in components:
            if ":" in component:
                metric = component.strip()
                score += self.cvss_patterns.get(metric, 0.0)
        
        # Normalize to 0-1 range
        max_possible_score = len([k for k in self.cvss_patterns.keys() if k.startswith(("AV:", "AC:", "PR:", "UI:", "C:", "I:", "A:"))])
        return min(score / max_possible_score, 1.0) if max_possible_score > 0 else 0.5
    
    def _calculate_exploitability_score(
        self, 
        vulnerability: Dict[str, Any], 
        threat_intel: ThreatIntelligence
    ) -> float:
        """Calculate exploitability score"""
        base_exploitability = 0.5
        
        # Check threat intel exploitability
        exploit_scores = {
            ExploitabilityLevel.ACTIVE_EXPLOITATION: 1.0,
            ExploitabilityLevel.PUBLIC_EXPLOIT: 0.9,
            ExploitabilityLevel.FUNCTIONAL_EXPLOIT: 0.8,
            ExploitabilityLevel.PROOF_OF_CONCEPT: 0.7,
            ExploitabilityLevel.THEORETICAL: 0.4,
            ExploitabilityLevel.UNKNOWN: 0.5
        }
        
        base_exploitability = exploit_scores.get(threat_intel.exploitability, 0.5)
        
        # Check vulnerability description for exploit indicators
        description = vulnerability.get("description", "").lower()
        name = vulnerability.get("name", "").lower()
        
        for pattern in self.known_exploit_patterns:
            if re.search(pattern, description + " " + name, re.IGNORECASE):
                base_exploitability = min(base_exploitability + 0.1, 1.0)
                break
        
        # Check for specific high-exploitability conditions
        if any(keyword in description for keyword in [
            "remote code execution", "rce", "authentication bypass",
            "privilege escalation", "buffer overflow", "sql injection"
        ]):
            base_exploitability = min(base_exploitability + 0.2, 1.0)
        
        return base_exploitability
    
    def _calculate_business_score(
        self,
        vulnerability: Dict[str, Any],
        business_context: BusinessContext
    ) -> float:
        """Calculate business impact score"""
        score = business_context.business_impact_score
        
        # Asset criticality factor
        score *= (0.5 + business_context.asset_criticality * 0.5)
        
        # Data sensitivity factor
        score *= (0.5 + business_context.data_sensitivity * 0.5)
        
        # External exposure multiplier
        if business_context.external_exposure:
            score *= 1.5
        
        # Compliance requirement multiplier
        if business_context.compliance_requirement:
            score *= 1.3
        
        # Port-based exposure assessment
        if "port" in vulnerability:
            port = vulnerability["port"]
            if port in [80, 443, 22, 21, 23, 25, 53, 110, 143, 993, 995]:
                score *= 1.2  # Common exposed ports
        
        return min(score, 1.0)
    
    def _calculate_threat_score(self, threat_intel: ThreatIntelligence) -> float:
        """Calculate threat intelligence score"""
        score = 0.5
        
        if threat_intel.threat_actor_activity:
            score += 0.2
        
        if threat_intel.ransomware_campaigns:
            score += 0.3
        
        if threat_intel.apt_usage:
            score += 0.2
        
        if threat_intel.exploit_kits:
            score += 0.15
        
        if threat_intel.mass_exploitation:
            score += 0.25
        
        return min(score, 1.0)
    
    def _calculate_temporal_score(self, threat_intel: ThreatIntelligence) -> float:
        """Calculate temporal factors score"""
        score = 0.5
        
        # Patch availability factor
        if not threat_intel.patch_available:
            score += 0.3  # No patch = higher priority
        elif threat_intel.patch_age_days:
            # Older patches = lower urgency (people should have patched by now)
            if threat_intel.patch_age_days > 90:
                score -= 0.2
            elif threat_intel.patch_age_days > 30:
                score -= 0.1
            elif threat_intel.patch_age_days < 7:
                score += 0.2  # Very recent patch = high priority
        
        return max(min(score, 1.0), 0.0)
    
    def _determine_priority_level(self, final_score: float) -> Severity:
        """Determine priority level from final score"""
        if final_score >= 0.85:
            return Severity.CRITICAL
        elif final_score >= 0.70:
            return Severity.HIGH
        elif final_score >= 0.50:
            return Severity.MEDIUM
        elif final_score >= 0.30:
            return Severity.LOW
        else:
            return Severity.INFO
    
    def _generate_reasoning(
        self,
        vulnerability: Dict[str, Any],
        business_context: BusinessContext,
        threat_intel: ThreatIntelligence,
        score: VulnerabilityScore
    ) -> List[str]:
        """Generate human-readable reasoning for the prioritization"""
        reasons = []
        
        # Base score reasoning
        severity = vulnerability.get("severity", "unknown").lower()
        if severity in ["critical", "high"]:
            reasons.append(f"High base severity ({severity})")
        
        # CVSS reasoning
        if vulnerability.get("cvss_score"):
            reasons.append(f"CVSS score: {vulnerability['cvss_score']}")
        
        # Exploitability reasoning
        if threat_intel.exploitability in [ExploitabilityLevel.ACTIVE_EXPLOITATION, ExploitabilityLevel.PUBLIC_EXPLOIT]:
            reasons.append(f"Active exploitation or public exploits available")
        
        # Business context reasoning
        if business_context.external_exposure:
            reasons.append("Asset exposed to internet")
        
        if business_context.asset_criticality > 0.7:
            reasons.append("High-criticality asset")
        
        if business_context.compliance_requirement:
            reasons.append("Subject to compliance requirements")
        
        # Threat intel reasoning
        if threat_intel.ransomware_campaigns:
            reasons.append("Used in ransomware campaigns")
        
        if threat_intel.apt_usage:
            reasons.append("Associated with APT activities")
        
        if threat_intel.mass_exploitation:
            reasons.append("Subject to mass exploitation")
        
        # Temporal reasoning
        if not threat_intel.patch_available:
            reasons.append("No patch available")
        elif threat_intel.patch_age_days and threat_intel.patch_age_days < 7:
            reasons.append("Recently patched vulnerability")
        
        return reasons
    
    def get_priority_summary(self, prioritized_vulns: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate priority summary statistics"""
        if not prioritized_vulns:
            return {"total": 0, "by_priority": {}, "top_concerns": []}
        
        priority_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        
        for vuln in prioritized_vulns:
            priority = vuln.get("priority_level", "info")
            priority_counts[priority] = priority_counts.get(priority, 0) + 1
        
        # Get top 5 concerns
        top_concerns = prioritized_vulns[:5]
        
        return {
            "total": len(prioritized_vulns),
            "by_priority": priority_counts,
            "top_concerns": [
                {
                    "name": v.get("name"),
                    "priority_level": v.get("priority_level"),
                    "priority_score": round(v.get("priority_score", 0), 2),
                    "key_reasons": v.get("scoring_details", {}).get("reasoning", [])[:3]
                }
                for v in top_concerns
            ],
            "immediate_action_required": priority_counts.get("critical", 0) + priority_counts.get("high", 0)
        }